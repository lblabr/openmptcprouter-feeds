From 52aae0c51a7bcd45752ad89475604e34247b48c7 Mon Sep 17 00:00:00 2001
From: Michael Lowman <michael.d.lowman@gmail.com>
Date: Thu, 23 Oct 2025 22:48:23 +0200
Subject: [PATCH] Resolve issue with openssl 3.5.3 encrypt (#1956)

* Set output buffer size prior to encrypt operation

When calling EVP_PKEY_encrypt with a non-null output buffer,
the output buffer length must be provided. Attempts to write
beyond this length will fail.

* Rename keysize to output_buffer_len

This more accurately represents the meaning; it is the minimum
buffer allocation necessary for an encrypt or decrypt operation
to succeed. This is the same size for both ciphertext and
cleartext, as padding is applied.

* Avoid out-of-bounds access when base64 decoding short strings

Check the length before reading memory.

* Don't over-allocate followed by partial reads

We know how much we expect to read; the input buffer
has a defined size. Allocate the exact buffer expected
instead of a larger one with a read expected to return
only partial data. This makes it simpler to follow the
logic and to avoid off-by-one errors.

* Add warnings on silent truncation

Input should not be this long, but makes the expectations
of the code clearer.
---
 src/iperf_auth.c | 42 +++++++++++++++++++++++++-----------------
 1 file changed, 25 insertions(+), 17 deletions(-)

diff --git a/src/iperf_auth.c b/src/iperf_auth.c
index eda015099..4c38fa938 100644
--- a/src/iperf_auth.c
+++ b/src/iperf_auth.c
@@ -130,9 +130,9 @@ int Base64Encode(const unsigned char* buffer, const size_t length, char** b64tex
 
 size_t calcDecodeLength(const char* b64input) { //Calculates the length of a decoded string
     size_t len = strlen(b64input), padding = 0;
-    if (b64input[len-1] == '=' && b64input[len-2] == '=') //last two chars are =
+    if (len >= 2 && b64input[len-1] == '=' && b64input[len-2] == '=') //last two chars are =
         padding = 2;
-    else if (b64input[len-1] == '=') //last char is =
+    else if (len >= 1 && b64input[len-1] == '=') //last char is =
         padding = 1;
 
     return (len*3)/4 - padding;
@@ -235,26 +235,31 @@ int encrypt_rsa_message(const char *plaintext, EVP_PKEY *public_key, unsigned ch
     RSA *rsa = NULL;
 #endif
     unsigned char *rsa_buffer = NULL;
-    size_t encryptedtext_len = 0;
-    int rsa_buffer_len, keysize;
+    size_t encryptedtext_len = 0, plaintext_len = 0;
+    int rsa_buffer_len, output_buffer_len;
 
 #if OPENSSL_VERSION_MAJOR >= 3
     int rc;
     ctx = EVP_PKEY_CTX_new_from_pkey(NULL, public_key, "");
     /* See evp_pkey_rsa(7) and provider-keymgmt(7) */
-    rc = EVP_PKEY_get_int_param(public_key, OSSL_PKEY_PARAM_MAX_SIZE, &keysize); /* XXX not really keysize */
+    rc = EVP_PKEY_get_int_param(public_key, OSSL_PKEY_PARAM_MAX_SIZE, &output_buffer_len);
     if (!rc) {
         goto errreturn;
     }
 #else
     rsa = EVP_PKEY_get1_RSA(public_key);
-    keysize = RSA_size(rsa);
+    output_buffer_len = RSA_size(rsa);
 #endif
-    rsa_buffer  = OPENSSL_malloc(keysize * 2);
-    *encryptedtext = (unsigned char*)OPENSSL_malloc(keysize);
+    plaintext_len = strlen(plaintext);
+    if (plaintext_len > output_buffer_len) {
+        fprintf(stderr, "Plaintext of size %zd truncated to %d; data is lost.\n", plaintext_len, output_buffer_len);
+    }
+    rsa_buffer  = OPENSSL_malloc(output_buffer_len);
+    *encryptedtext = (unsigned char*)OPENSSL_malloc(output_buffer_len);
+    encryptedtext_len = output_buffer_len;
 
-    BIO *bioBuff   = BIO_new_mem_buf((void*)plaintext, (int)strlen(plaintext));
-    rsa_buffer_len = BIO_read(bioBuff, rsa_buffer, keysize * 2);
+    BIO *bioBuff   = BIO_new_mem_buf((void*)plaintext, (int)plaintext_len);
+    rsa_buffer_len = BIO_read(bioBuff, rsa_buffer, plaintext_len);
 
     int padding = RSA_PKCS1_OAEP_PADDING;
     if (use_pkcs1_padding){
@@ -294,25 +299,28 @@ int decrypt_rsa_message(const unsigned char *encryptedtext, const int encryptedt
 #endif
     unsigned char *rsa_buffer = NULL;
     size_t plaintext_len = 0;
-    int rsa_buffer_len, keysize;
+    int rsa_buffer_len, output_buffer_len;
 
 #if OPENSSL_VERSION_MAJOR >= 3
     int rc;
     ctx = EVP_PKEY_CTX_new_from_pkey(NULL, private_key, "");
     /* See evp_pkey_rsa(7) and provider-keymgmt(7) */
-    rc = EVP_PKEY_get_int_param(private_key, OSSL_PKEY_PARAM_MAX_SIZE, &keysize); /* XXX not really keysize */
+    rc = EVP_PKEY_get_int_param(private_key, OSSL_PKEY_PARAM_MAX_SIZE, &output_buffer_len);
     if (!rc) {
         goto errreturn;
     }
 #else
     rsa = EVP_PKEY_get1_RSA(private_key);
-    keysize = RSA_size(rsa);
+    output_buffer_len = RSA_size(rsa);
 #endif
-    rsa_buffer  = OPENSSL_malloc(keysize * 2);
+    if (encryptedtext_len > output_buffer_len) {
+        fprintf(stderr, "Encrypted text of size %d truncated to %d; likely invalid input.\n", encryptedtext_len, output_buffer_len);
+    }
+    rsa_buffer  = OPENSSL_malloc(output_buffer_len);
-    *plaintext = (unsigned char*)OPENSSL_malloc(keysize);
+    *plaintext = (unsigned char*)OPENSSL_malloc(output_buffer_len + 1);
 
     BIO *bioBuff   = BIO_new_mem_buf((void*)encryptedtext, encryptedtext_len);
-    rsa_buffer_len = BIO_read(bioBuff, rsa_buffer, keysize * 2);
+    rsa_buffer_len = BIO_read(bioBuff, rsa_buffer, encryptedtext_len);
 
     int padding = RSA_PKCS1_OAEP_PADDING;
     if (use_pkcs1_padding){
@@ -321,5 +329,5 @@ int decrypt_rsa_message(const unsigned char *encryptedtext, const int encryptedt
     }
 #if OPENSSL_VERSION_MAJOR >= 3
-    plaintext_len = keysize;
+    plaintext_len = output_buffer_len;
     EVP_PKEY_decrypt_init(ctx);
     int ret = EVP_PKEY_CTX_set_rsa_padding(ctx, padding);
